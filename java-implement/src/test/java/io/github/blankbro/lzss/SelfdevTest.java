package io.github.blankbro.lzss;

import lombok.extern.slf4j.Slf4j;
import org.junit.Test;

import java.time.Duration;

@Slf4j
public class SelfdevTest {

    @Test
    public void testOnce() throws InterruptedException {
        int[] intArr = {0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x0F, 0x48, 0xA1, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x64, 0x0F, 0x6F, 0x0F, 0x6D, 0x0F, 0x6F, 0x0F, 0x71, 0x0F, 0x6D, 0x0F, 0x6E, 0x0F, 0x73, 0x0F, 0x6D, 0x0F, 0x6F, 0x0F, 0x72, 0x0F, 0x6D, 0x0F, 0x6C, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x12, 0x49, 0x0C, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x68, 0x0F, 0x73, 0x0F, 0x6F, 0x0F, 0x73, 0x0F, 0x73, 0x0F, 0x6F, 0x0F, 0x73, 0x0F, 0x77, 0x0F, 0x6F, 0x0F, 0x73, 0x0F, 0x76, 0x0F, 0x6F, 0x0F, 0x6E, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x18, 0x49, 0x77, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x6D, 0x0F, 0x77, 0x0F, 0x73, 0x0F, 0x77, 0x0F, 0x77, 0x0F, 0x74, 0x0F, 0x76, 0x0F, 0x79, 0x0F, 0x74, 0x0F, 0x77, 0x0F, 0x79, 0x0F, 0x73, 0x0F, 0x73, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x17, 0x49, 0x71, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x6C, 0x0F, 0x77, 0x0F, 0x73, 0x0F, 0x77, 0x0F, 0x77, 0x0F, 0x73, 0x0F, 0x76, 0x0F, 0x79, 0x0F, 0x73, 0x0F, 0x77, 0x0F, 0x79, 0x0F, 0x73, 0x0F, 0x73, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x1C, 0x49, 0xD6, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x71, 0x0F, 0x7B, 0x0F, 0x77, 0x0F, 0x7B, 0x0F, 0x7B, 0x0F, 0x77, 0x0F, 0x79, 0x0F, 0x7C, 0x0F, 0x77, 0x0F, 0x79, 0x0F, 0x7D, 0x0F, 0x77, 0x0F, 0x76, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x1D, 0x49, 0xD6, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x71, 0x0F, 0x7B, 0x0F, 0x77, 0x0F, 0x7B, 0x0F, 0x7B, 0x0F, 0x77, 0x0F, 0x79, 0x0F, 0x7D, 0x0F, 0x78, 0x0F, 0x7B, 0x0F, 0x7D, 0x0F, 0x77, 0x0F, 0x77, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x22, 0x4A, 0x40, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x74, 0x0F, 0x7D, 0x0F, 0x7B, 0x0F, 0x7E, 0x0F, 0x7E, 0x0F, 0x7B, 0x0F, 0x7D, 0x0F, 0x81, 0x0F, 0x7C, 0x0F, 0x7D, 0x0F, 0x82, 0x0F, 0x7B, 0x0F, 0x7B, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x22, 0x4A, 0x3A, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x74, 0x0F, 0x7E, 0x0F, 0x7B, 0x0F, 0x7E, 0x0F, 0x7E, 0x0F, 0x7B, 0x0F, 0x7D, 0x0F, 0x81, 0x0F, 0x7C, 0x0F, 0x7E, 0x0F, 0x81, 0x0F, 0x7B, 0x0F, 0x7B, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x27, 0x4A, 0xA5, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x79, 0x0F, 0x82, 0x0F, 0x7E, 0x0F, 0x83, 0x0F, 0x82, 0x0F, 0x80, 0x0F, 0x82, 0x0F, 0x86, 0x0F, 0x81, 0x0F, 0x82, 0x0F, 0x85, 0x0F, 0x80, 0x0F, 0x7E, 0x03, 0x4E, 0x4F, 0x4F,
                0x00, 0x35, 0x00, 0x02, 0x23, 0x24, 0x14, 0x52, 0x4E, 0x1E, 0x52, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D, 0x0F, 0x9E, 0x0F, 0xA1, 0x0F, 0x9F, 0x0F, 0xA4, 0x0F, 0xA3, 0x0F, 0xA0, 0x0F, 0xA1, 0x0F, 0xA5, 0x0F, 0xA1, 0x0F, 0xA1, 0x0F, 0xA5, 0x0F, 0xA1, 0x0F, 0xA1, 0x03, 0x4E, 0x4F, 0x4F};
        byte[] byteArr = new byte[intArr.length];
        for (int i = 0; i < intArr.length; i++) {
            byteArr[i] = (byte) intArr[i];
        }

        for (int i = 0; i < 10000; i++) {
            long start = System.nanoTime();
            Selfdev.EncodeResult encodeResult = Selfdev.encode(byteArr, 10);
            long end = System.nanoTime();
            long encodeHandleTime = end - start;

            start = System.nanoTime();
            byte[] decodeResult = Selfdev.decode(encodeResult);
            end = System.nanoTime();
            long decodeHandleTime = end - start;

            for (int j = 0; j < decodeResult.length; j++) {
                if (byteArr[j] != decodeResult[j]) {
                    System.out.println("解压不一致");
                    break;
                }
            }

            byte[] encodeBytes = encodeResult.getBytes();
            log.info("originByteArray:  {} bytes", byteArr.length);
            log.info("encodeByteArray:  {} bytes ({}%)", encodeBytes.length, encodeBytes.length * 100.0 / byteArr.length);
            log.info("encodeByteArray + 2 + 2:  {} bytes ({}%)", encodeBytes.length + 4, (encodeBytes.length + 4) * 100.0 / byteArr.length);
            log.info("压缩耗时：{}", TimeUtil.formatDuration(Duration.ofNanos(encodeHandleTime)));
            log.info("解压耗时：{}", TimeUtil.formatDuration(Duration.ofNanos(decodeHandleTime)));

            Thread.sleep(1000);
        }


    }

    @Test
    public void testBit() {
        int ia = 0b1000_0000;
        System.out.println(ia);
        byte a = (byte) ia;
        System.out.println(a);
        System.out.println((int) a);

        byte b = -1;
        System.out.println((int) b);
    }
}
